

POLITECHNIKA ŒL¥SKA
Wydzia³ In¿ynierii Materia³owej

Tworzenie aplikacji internetowych i bazodanowych
TEMAT:
Tokyo Garden Restaurant — Dokumentacja ProjektuUwagi prowadz¹cego:Data ostatniej modyfikacji:
16.09.2025


Podpis prowadz¹cego:Imiê i nazwisko:
1. Jakub Majer
2. Wojciech Kin
3. Szymon Czapla
4. Dominik DeszczkaGrupa dziekañska: TP 4.0

0. STRESZCZENIE WYKONAWCZE	3
CEL BIZNESOWY	3
ZAKRES SYSTEMU	3
KORZYŒCI I MIERNIKI	3
1. SPECYFIKACJA	3
KONTEKST I INTERESARIUSZE	3
PRZYPADKI U¯YCIA (SKRÓT)	4
WYMAGANIA NIEFUNKCJONALNE	4
2. MODEL DANYCH I DOMENY	4
CDM – ENCJE I RELACJE	4
PDM – TABELE I KLUCZE	6
3. ARCHITEKTURA I WARSTWY	9
PRZEGL¥D	9
WZORCE I DECYZJE PROJEKTOWE	9
WARSTWA MODEL	9
WARSTWA IDAL	10
WARSTWA DAL	11
WARSTWA IBL	11
WARSTWA BIZNESOWA	12
API – WEB	13
DTOMAPPER.CS	14
DTO	15
FRONTEND – ANGULAR	15
BEZPIECZEÑSTWO I ZGODNOŒÆ	15
4. TESTY (PODEJŒCIE I ZAKRES)	16
ZASADY OGÓLNE	16
DOUBLES W£ASNE I MOQ	16
TESTY DAL Z INMEMORY	16
5. INTERFEJS WEB API (KONTRAKT I ZASADY)	17
KONWENCJE REST	17
PRZYK£ADOWE ZASOBY I OPERACJE	17
WALIDACJA I B£ÊDY	17
PAGINACJA/SORTOWANIE/FILTROWANIE	17
6. FRONTEND (ANGULAR)	17
STRUKTURA I WZORCE	17
UX I WALIDACJE	18
MAPOWANIE DTO	18
7. BEZPIECZEÑSTWO I ZGODNOŒÆ	18
AUTORYZACJA I ROLE	18
CORS I OCHRONA DANYCH	18

0. Streszczenie wykonawcze
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
Cel biznesowy
Celem systemu Tokyo Garden Restaurant jest wsparcie pe³nego cyklu ¿ycia zarz¹dzania ofert¹ i zamówieniami w restauracji: od definicji kategorii i pozycji menu (ze sk³adnikami i alergenami), przez zbieranie zamówieñ klientów, po administracjê danymi u¿ytkowników i adresów dostaw. System ma u³atwiæ codzienn¹ pracê obs³udze i zapewniæ spójnoœæ danych.
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
Zakres systemu
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
System sk³ada siê z backendu opartego na ASP.NET Core Web API, z warstwami logiki biznesowej (BL) i dostêpu do danych (DAL) wykorzystuj¹cymi Entity Framework Core, oraz frontendu zbudowanego w technologii Angular. Backend udostêpnia REST-owe endpointy wspieraj¹ce operacje CRUD oraz specyficzne operacje domenowe, takie jak filtrowanie czy walidacja danych. Frontend zapewnia panel administracyjny do zarz¹dzania danymi oraz widoki dla klientów, umo¿liwiaj¹ce przegl¹danie menu, sk³adanie zamówieñ i œledzenie ich statusu.
Korzyœci i mierniki
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
System TokyoGarden przynosi nastêpuj¹ce korzyœci:
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
Redukcja b³êdów: Wymuszone relacje i walidacje w warstwie BL minimalizuj¹ niepoprawnoœæ danych.
Szybsza obs³uga katalogu: Usprawnione zarz¹dzanie kategoriami, alergenami i zdjêciami pozycji menu.
Skalowalnoœæ: Warstwowa architektura i wzorzec repozytorium zapewniaj¹ elastycznoœæ i ³atwoœæ rozbudowy.
Mierniki efektywnoœci: Czas wprowadzania zmiany w pozycji menu, liczba b³êdów w zamówieniach wykrytych przez walidacjê, czasy odpowiedzi endpointów API.
Doprecyzowano kontrakty REST – opisano wszystkie pola w DTO, podano przyk³adowe requesty i response’y dla metod GET, POST i PUT. Uwzglêdniono równie¿ obs³ugê b³êdów z kodami statusu i formatem ProblemDetails. Dodano sugestie wersjonowania API w przysz³oœci (np. /api/v2) w razie rozbudowy systemu.
1. Specyfikacja
Kontekst i interesariusze
System TokyoGarden jest przeznaczony dla ró¿nych grup interesariuszy, z których ka¿da ma specyficzne potrzeby:
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
Klienci: Przegl¹daj¹ menu, filtruj¹ pozycje wed³ug kategorii i alergenów, sk³adaj¹ zamówienia.
Administratorzy/Pracownicy: Zarz¹dzaj¹ danymi menu, kategoriami, alergenami oraz statusami zamówieñ.
W³aœciciele: Korzystaj¹ z raportów i nadzoruj¹ operacje restauracji. W przysz³oœci system mo¿e zostaæ zintegrowany z zewnêtrzn¹ bramk¹ p³atnicz¹, co rozszerzy jego funkcjonalnoœæ o obs³ugê p³atnoœci online.
Przypadki u¿ycia (skrót)
Kluczowe przypadki u¿ycia obejmuj¹:
Klient: Przegl¹danie menu, filtrowanie pozycji wed³ug kategorii lub alergenów, sk³adanie i œledzenie zamówieñ.
Administrator: Dodawanie, edycja i usuwanie pozycji menu, przypisywanie kategorii i alergenów, aktualizacja statusów zamówieñ.
System: Automatyczna walidacja danych, zapewnienie spójnoœci relacji miêdzy encjami, obliczanie wartoœci zamówieñ na podstawie pozycji i ich iloœci.
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
Wymagania niefunkcjonalne
System spe³nia nastêpuj¹ce wymagania niefunkcjonalne:
System zosta³ zaprojektowany w oparciu o analizê potrzeb restauracji, z uwzglêdnieniem wygody u¿ytkownika, minimalizacji b³êdów i mo¿liwoœci rozbudowy w przysz³oœci. Dokumentacja opisuje szczegó³owo ka¿dy element – od koncepcji po implementacjê – tak aby mog³a stanowiæ punkt odniesienia przy dalszym rozwoju systemu lub jego utrzymaniu.
Wydajnoœæ: Endpointy listowe wspieraj¹ paginacjê, sortowanie i filtrowanie, zapewniaj¹c szybkie odpowiedzi nawet przy du¿ej liczbie danych.
Bezpieczeñstwo: Autoryzacja oparta na rolach (Admin/User) z planowan¹ rozbudow¹ o JWT, walidacja danych wejœciowych, zabezpieczenia CORS.
Utrzymywalnoœæ: Warstwowa architektura z Dependency Injection (DI) i jasno zdefiniowanymi kontraktami u³atwia konserwacjê i rozwój.
Jakoœæ kodu: Testy jednostkowe dla warstw BL, DAL i kontrolerów zapewniaj¹ niezawodnoœæ i poprawnoœæ dzia³ania.
2. Model danych i domeny
CDM – encje i relacje
Diagram Konceptualnego Modelu Danych (CDM) systemu TokyoGarden przedstawia w sposób precyzyjny i uporz¹dkowany logiczn¹ strukturê danych, która wspiera kluczowe procesy zamawiania i realizacji us³ug w restauracji, zapewniaj¹c przejrzystoœæ dla projektantów i interesariuszy biznesowych. Model ten koncentruje siê na definiowaniu g³ównych encji, ich atrybutów oraz wzajemnych relacji, celowo pomijaj¹c techniczne detale, takie jak typy danych, indeksy czy ograniczenia bazodanowe, aby u³atwiæ zrozumienie ogólnej organizacji danych w systemie. Jego nadrzêdnym celem jest dostarczenie klarownego, logicznego obrazu struktury danych, który stanowi fundament dla dalszego projektowania i implementacji bazy danych, wspieraj¹c efektywne zarz¹dzanie procesami restauracyjnymi. Model CDM obejmuje szeœæ g³ównych encji, z których ka¿da odzwierciedla specyficzne aspekty funkcjonalnoœci systemu TokyoGarden, zapewniaj¹c kompleksowe wsparcie dla operacji restauracyjnych:
1. Adresy: Encja przechowuj¹ca szczegó³owe dane lokalizacyjne u¿ytkowników lub miejsc dostawy, zawieraj¹ca atrybuty takie jak miasto, ulica, numer domu oraz numer mieszkania, co umo¿liwia precyzyjne okreœlenie lokalizacji dla potrzeb logistycznych systemu.
2. U¿ytkownicy: Reprezentuje klientów oraz administratorów korzystaj¹cych z platformy, z atrybutami obejmuj¹cymi nazwê u¿ytkownika, has³o, numer telefonu oraz klucz obcy fk_id_adresu, który jednoznacznie wi¹¿e ka¿dego u¿ytkownika z dok³adnie jednym adresem w systemie.
3. Zamówienia: Przechowuje szczegó³owe informacje dotycz¹ce zamówieñ sk³adanych przez u¿ytkowników, w tym datê zamówienia, dodatkowe uwagi (np. proœba o szybk¹ dostawê), opis zamówienia oraz klucze obce fk_id_u¿ytkownika i fk_id_adresu, które ³¹cz¹ zamówienie z u¿ytkownikiem i adresem dostawy.
4. Pozycje Zamówienia: Reprezentuje produkty wybrane w ramach pojedynczego zamówienia, z atrybutami takimi jak cena jednostkowa pozycji oraz liczba zamówionych sztuk, powi¹zana z encjami Zamówienia i Pozycje Menu, co pozwala na precyzyjne okreœlenie sk³adu ka¿dego zamówienia.
5. Pozycje Menu: Zawiera dane dotycz¹ce dañ dostêpnych w ofercie restauracji, w tym nazwê pozycji, opis, cenê oraz dane obrazu (imageData), powi¹zana z Kategoriami Menu, co umo¿liwia logiczne grupowanie dañ wed³ug okreœlonych kategorii.
6. Kategorie Menu: S³u¿y do organizowania dañ w grupy, takie jak przystawki, dania g³ówne czy desery, z atrybutem nazwa_kategorii (np. „Sushi” lub „Zupy”), co znacz¹co u³atwia prezentacjê oferty w przejrzysty i uporz¹dkowany sposób.
Relacje w modelu:
* Relacja U¿ytkownicy ? Adresy (1:N): Jeden adres mo¿e byæ przypisany do wielu u¿ytkowników, co odzwierciedla mo¿liwoœæ wspó³dzielenia lokalizacji przez ró¿nych klientów lub administratorów.
* Relacja Zamówienia ? U¿ytkownicy (N:1): Ka¿de zamówienie jest przypisane dok³adnie jednemu u¿ytkownikowi, co zapewnia jednoznacznoœæ odpowiedzialnoœci za zamówienie.
* Relacja Zamówienia ? Adresy (N:1): Ka¿de zamówienie jest powi¹zane z jednym adresem dostawy, co pozwala na precyzyjne okreœlenie miejsca realizacji us³ugi.
* Relacja Pozycje Zamówienia ? Zamówienia (N:1): Ka¿da pozycja zamówienia nale¿y do dok³adnie jednego zamówienia, co umo¿liwia szczegó³owe œledzenie zawartoœci koszyka.
* Relacja Pozycje Zamówienia ? Pozycje Menu (N:1): Ka¿da pozycja zamówienia odnosi siê do jednego dania z menu, co zapewnia spójnoœæ oferty z wyborem klienta.
* Relacja Pozycje Menu ? Kategorie Menu (N:1): Ka¿de danie nale¿y do jednej kategorii menu, co u³atwia organizacjê i przegl¹danie oferty restauracyjnej.
Model CDM systemu TokyoGarden gwarantuje logiczne i precyzyjne odwzorowanie procesów zamawiania, umo¿liwiaj¹c efektywne zarz¹dzanie danymi oraz ich przejrzyst¹ organizacjê, co stanowi solidn¹ podstawê dla projektowania i implementacji bazy danych w dalszych etapach rozwoju systemu.
PDM – tabele i klucze
Diagram Fizycznego Modelu Danych (PDM) systemu TokyoGarden definiuje szczegó³ow¹ strukturê bazy danych dla SQL Server, uwzglêdniaj¹c techniczne aspekty, takie jak typy danych, klucze g³ówne i obce, ograniczenia integralnoœci oraz konfiguracje wspieraj¹ce migracje bazy danych i Entity Framework Core. Model ten zapewnia zgodnoœæ z wymaganiami systemu, umo¿liwiaj¹c generowanie skryptów SQL oraz efektywne zarz¹dzanie danymi restauracyjnymi, co jest kluczowe dla prawid³owego funkcjonowania aplikacji. Baza danych sk³ada siê z oœmiu tabel, które odzwierciedlaj¹ strukturê danych i zale¿noœci miêdzy nimi, wspieraj¹c wszystkie kluczowe operacje systemu:
1. Adresy: Przechowuje dane lokalizacyjne, takie jak id_adres (int, klucz g³ówny), miasto (varchar(255)), ulica (varchar(255)), nr_domu (varchar(255)), nr_mieszkania (varchar(255)), co pozwala na precyzyjne okreœlenie miejsca dostawy.
2. U¿ytkownicy: Reprezentuje klientów i administratorów, z atrybutami id_uzytkownika (int, klucz g³ówny), nazwa_uzytkownika (varchar(255)), haslo (varchar(255)), email (varchar(255)), nr_telefonu (varchar(255)), wspieraj¹c autoryzacjê i komunikacjê z u¿ytkownikami.
3. Zamówienia: Przechowuje szczegó³owe dane zamówieñ, w tym id_zamowienia (int, klucz g³ówny), data_zamowienia (datetime), dodatkowe_informacje (varchar(255)), id_uzytkownika (int, klucz obcy), id_adres (int, klucz obcy), metoda_platnosci (varchar(255)), status_zamowienia (varchar(255)), co stanowi centralny element zarz¹dzania procesami zamawiania.
4. Pozycje_Zamowienia: Okreœla produkty w zamówieniu, z atrybutami id_pozycja_zamowienia (int, klucz g³ówny), ilosc (int), id_pozycja_menu (int, klucz obcy), id_zamowienia (int, klucz obcy), umo¿liwiaj¹c szczegó³owe okreœlenie sk³adu ka¿dego zamówienia.
5. Pozycje_Menu: Przechowuje informacje o daniach, w tym id_pozycja_menu (int, klucz g³ówny), cena (int), nazwa_pozycji (varchar(255)), opis (varchar(255)), imageData (varchar(255)), id_kategorii (int, klucz obcy), co pozwala na prezentacjê pe³nej oferty restauracji.
6. Kategorie: Grupuje dania w kategorie, takie jak przystawki czy desery, z atrybutami id_kategorii (int, klucz g³ówny), nazwa_kategorii (varchar(255)), co u³atwia organizacjê menu w aplikacji.
7. Alergeny: Przechowuje dane o alergenach, z atrybutami id_alergenu (int, klucz g³ówny), opis_alergenu (varchar(255)), co wspiera informowanie klientów o potencjalnych zagro¿eniach zdrowotnych.
8. Alergeny_Pozycje_Menu: £¹czy alergeny z daniami, z atrybutami id_alergenu_pozycje_menu (int, klucz g³ówny), id_alergenu (int, klucz obcy), id_pozycja_menu (int, klucz obcy), umo¿liwiaj¹c precyzyjne okreœlenie alergenów dla ka¿dej pozycji menu.
Relacje w modelu:
* Relacja U¿ytkownicy ? Zamówienia (1:N): Jeden u¿ytkownik mo¿e z³o¿yæ wiele zamówieñ, co odzwierciedla aktywnoœæ klienta w systemie.
* Relacja Adresy ? Zamówienia (1:N): Jeden adres mo¿e byæ u¿ywany w wielu zamówieniach, co pozwala na elastyczne zarz¹dzanie lokalizacjami dostaw.
* Relacja Zamówienia ? Pozycje_Zamowienia (1:N): Jedno zamówienie mo¿e zawieraæ wiele pozycji, co umo¿liwia szczegó³owe okreœlenie zawartoœci koszyka.
* Relacja Pozycje_Menu ? Pozycje_Zamowienia (1:N): Jedna pozycja menu mo¿e wystêpowaæ w wielu pozycjach zamówienia, co zapewnia spójnoœæ oferty.
* Relacja Kategorie ? Pozycje_Menu (1:N): Jedna kategoria mo¿e zawieraæ wiele pozycji menu, co u³atwia organizacjê oferty kulinarnej.
* Relacja Alergeny ? Pozycje_Menu (N:N): Powi¹zanie realizowane przez tabelê Alergeny_Pozycje_Menu, co pozwala na elastyczne przypisywanie alergenów do dañ.
Konwencje i integralnoœæ:
* Klucze g³ówne (PK) s¹ zdefiniowane jako identyfikatory (Id) typu int, zapewniaj¹ce unikalnoœæ rekordów.
* Klucze obce (FK) stosuj¹ ograniczenia kaskadowe tylko tam, gdzie jest to uzasadnione, np. brak kaskadowego usuwania zamówieñ przy usuwaniu u¿ytkownika, aby zachowaæ integralnoœæ historycznych danych.
* Indeksy zdefiniowano dla pól czêsto wyszukiwanych, takich jak nazwa_pozycji i data_zamowienia, oraz dla kluczy obcych, co zwiêksza wydajnoœæ zapytañ.
* Walidacje obejmuj¹ wymagane pola (np. nazwy, ceny), ograniczenia wartoœci (ceny > 0, iloœci > 0) oraz relacjê N:M dla alergenów i pozycji menu poprzez tabelê ³¹cz¹c¹.
Model PDM systemu TokyoGarden stanowi solidn¹ techniczn¹ podstawê, umo¿liwiaj¹c efektywn¹ implementacjê bazy danych w SQL Server oraz wspieraj¹c kluczowe procesy zamawiania i zarz¹dzania ofert¹ restauracyjn¹.

Diagram Klas UML
Diagram klas UML systemu TokyoGarden przedstawia szczegó³ow¹, obiektow¹ strukturê danych, definiuj¹c klasy, ich atrybuty oraz relacje miêdzy nimi, co wspiera programowanie obiektowe, komunikacjê miêdzy backendem a frontendem oraz generowanie dokumentacji technicznej. Model ten jest kluczowy dla projektowania logiki biznesowej, definiowania struktur danych w kodzie oraz zapewnienia spójnoœci w implementacji aplikacji. Obejmuje osiem klas, które odzwierciedlaj¹ g³ówne komponenty systemu, wspieraj¹c zarówno backend, jak i frontend:
1. Adres: Zawiera atrybuty id (int, unikalny identyfikator), miasto (String, nazwa miejscowoœci), ulica (String, nazwa ulicy), nr_domu (int, numer budynku), nr_mieszkania (int, numer mieszkania), co umo¿liwia precyzyjne zarz¹dzanie danymi lokalizacyjnymi w systemie.
2. U¿ytkownik: Przechowuje dane u¿ytkowników, w tym id_u¿ytkownika (int, unikalny identyfikator), nazwa_u¿ytkownika (String, login), has³o (String, zaszyfrowane), telefon (String, numer kontaktowy), co wspiera zarz¹dzanie kontami klientów i administratorów.
3. Zamówienie: Reprezentuje pojedyncze zamówienie, z atrybutami id_zamówienia (int, unikalny identyfikator), data_zamówienia (DateTime, data z³o¿enia), dodatkowe_informacje (String, uwagi klienta), status_zamówienia (String, np. „Nowy”), ³¹czna_cena (double, koszt ca³kowity), metoda_p³atnoœci (String, np. „gotówka”), opcje_zamówienia (String, rodzaj zamówienia), u¿ytkownik_id (int, klucz obcy), co czyni j¹ centralnym elementem systemu.
4. PozycjaZamówienia: Przechowuje informacje o produktach w zamówieniu, z atrybutami id_pozycje_zamówienia (int, unikalny identyfikator), cena (double, koszt pozycji), iloœæ (int, liczba sztuk), pozycja_menu_id (int, klucz obcy), zamówienie_id (int, klucz obcy), co pozwala na szczegó³owe okreœlenie sk³adu zamówienia.
5. PozycjaMenu: Reprezentuje dania w menu, z atrybutami id_pozycja_menu (int, unikalny identyfikator), nazwa (String, nazwa dania), opis (String, szczegó³y przygotowania), cena (double, koszt), sk³adniki (String, lista sk³adników), co wspiera prezentacjê oferty restauracyjnej.
6. Kategoria: Grupuje dania w kategorie, z atrybutami id_kategoria (int, unikalny identyfikator), nazwa_kategorii (String, np. „Przystawki”), co u³atwia organizacjê menu w aplikacji.
7. Alergen: Przechowuje informacje o alergenach, z atrybutami id_alergen (int, unikalny identyfikator), nazwa (String, nazwa alergenu), opis_alergenu (String, szczegó³owy opis), co wspiera informowanie klientów o potencjalnych zagro¿eniach.
8. AlergenPozycjaMenu: Klasa ³¹cz¹ca dla relacji wiele-do-wielu, z atrybutami pozycja_menu_id (int, klucz obcy), alergen_id (int, klucz obcy), co umo¿liwia przypisanie alergenów do pozycji menu.
Relacje w modelu:
* Relacja U¿ytkownik ? Adres (1:N): Jeden adres mo¿e byæ przypisany wielu u¿ytkownikom, co odzwierciedla wspó³dzielenie lokalizacji.
* Relacja U¿ytkownik ? Zamówienie (1:N): Jeden u¿ytkownik mo¿e z³o¿yæ wiele zamówieñ, co zapewnia jednoznacznoœæ odpowiedzialnoœci.
* Relacja Zamówienie ? PozycjaZamówienia (1:N): Jedno zamówienie zawiera wiele pozycji, co pozwala na szczegó³owe okreœlenie zawartoœci.
* Relacja PozycjaZamówienia ? PozycjaMenu (N:1): Ka¿da pozycja zamówienia odnosi siê do jednego dania, co zapewnia spójnoœæ z menu.
* Relacja PozycjaMenu ? Kategoria (N:1): Ka¿de danie nale¿y do jednej kategorii, co u³atwia organizacjê oferty.
* Relacja PozycjaMenu ? Alergen (N:N): Realizowana przez klasê AlergenPozycjaMenu, co umo¿liwia elastyczne przypisywanie alergenów.
Diagram klas UML wspiera projektowanie struktur encji w warstwie TokyoGarden.Model, definiowanie obiektów DTO, konfiguracjê relacji w Entity Framework Core, komunikacjê miêdzy zespo³ami deweloperskimi oraz generowanie dokumentacji i testów jednostkowych, zapewniaj¹c wysok¹ jakoœæ kodu.
3. Architektura i warstwy
Przegl¹d
Architektura systemu TokyoGarden opiera siê na warstwowym podejœciu, które obejmuje nastêpuj¹ce komponenty: Model (klasy POCO), IDAL (interfejsy repozytoriów i UnitOfWork), DAL (implementacje repozytoriów z Entity Framework Core), IBL (interfejsy us³ug biznesowych), BL (implementacje logiki biznesowej), API (ASP.NET Core Web API) oraz UI (Angular). Zasada projektowa zak³ada, ¿e warstwa BL komunikuje siê z IDAL, a API z IBL, eliminuj¹c zale¿noœci wsteczne, co zapewnia modularnoœæ i ³atwoœæ utrzymania systemu.

Wzorce i decyzje projektowe
System wykorzystuje nastêpuj¹ce wzorce projektowe:
* Repository i UnitOfWork: Ujednolicone kontrakty dla operacji CRUD i zarz¹dzania transakcjami, zapewniaj¹ce spójnoœæ danych.
* DTO vs Model: API operuje na obiektach DTO, podczas gdy BL korzysta z modeli domenowych, z mapowaniem realizowanym w warstwie API.
* Dependency Injection (DI)/Inversion of Control (IoC): Kontrolery wstrzykuj¹ interfejsy IBL, a BL wstrzykuje IDAL, co wspiera testowalnoœæ i modularnoœæ.
* Walidacja: Logika biznesowa w BL, wstêpna walidacja atrybutami w DTO, co zapewnia spójnoœæ i bezpieczeñstwo danych.
Warstwa Model
Warstwa Model w aplikacji TokyoGarden zawiera klasy encji, które s¹ mapowane na tabele bazy danych SQL Server za pomoc¹ Entity Framework Core, zapewniaj¹c spójnoœæ danych i separacjê odpowiedzialnoœci miêdzy warstwami aplikacji. Encje te s¹ wykorzystywane w warstwach dostêpu do danych (DAL), logiki biznesowej (BL) oraz API, wspieraj¹c efektywne zarz¹dzanie danymi w systemie. Warstwa obejmuje siedem klas encji, z których ka¿da odpowiada za reprezentacjê okreœlonego typu danych:
1. Adresy: Przechowuje szczegó³owe dane lokalizacyjne u¿ytkowników lub miejsc dostawy, takie jak miasto, ulica, numer domu oraz numer mieszkania, co umo¿liwia precyzyjne okreœlenie lokalizacji dla potrzeb logistycznych.
2. Alergeny: Zawiera informacje o alergenach wystêpuj¹cych w produktach menu, takich jak orzechy czy gluten, co wspiera informowanie klientów o potencjalnych zagro¿eniach zdrowotnych.
3. Kategorie: Reprezentuje kategorie pozycji menu, takie jak Sushi, Ramen czy Napoje, co u³atwia organizacjê i prezentacjê oferty restauracyjnej w aplikacji.
4. Pozycje_Menu: Odpowiada za pojedyncze pozycje w menu, zawieraj¹ce szczegó³owe informacje o nazwie, opisie, cenie oraz danych obrazu, co wspiera prezentacjê oferty kulinarnej.
5. Pozycje_Zamowienia: Reprezentuje produkty w zamówieniu, z atrybutami takimi jak iloœæ i cena wybranej pozycji menu, co umo¿liwia szczegó³owe okreœlenie sk³adu koszyka.
6. U¿ytkownicy: Przechowuje dane u¿ytkowników systemu, w tym nazwê u¿ytkownika, has³o oraz dane kontaktowe, co wspiera autoryzacjê i komunikacjê z klientami oraz administratorami.
7. Zamówienia: Reprezentuje pe³ne zamówienie z³o¿one przez u¿ytkownika, obejmuj¹ce szczegó³y takie jak data zamówienia, status, ³¹czna cena oraz powi¹zane pozycje, co jest kluczowe dla zarz¹dzania procesami zamawiania.
Adnotacje Entity Framework Core:
* [Key]: Wskazuje atrybut pe³ni¹cy rolê klucza g³ównego, zapewniaj¹c unikalnoœæ rekordów w bazie danych.
* [Column(TypeName = "decimal(18,2)")]: Definiuje precyzyjny typ danych dla kolumn numerycznych, takich jak ceny, co zapewnia dok³adnoœæ obliczeñ finansowych.
* virtual ICollection<T>: Umo¿liwia lazy loading dla relacji jeden-do-wielu lub wiele-do-wielu, co pozwala na ³adowanie powi¹zanych danych na ¿¹danie.
* virtual T?: Obs³uguje relacje opcjonalne, np. u¿ytkownik w zamówieniu mo¿e byæ null, co zwiêksza elastycznoœæ modelowania danych.
Warstwa Model zapewnia solidn¹ podstawê dla mapowania obiektowo-relacyjnego, umo¿liwiaj¹c efektywne zarz¹dzanie danymi w aplikacji TokyoGarden.
Warstwa IDAL
Warstwa interfejsów dostêpu do danych (IDAL) w przestrzeni TokyoGarden.IDAL definiuje kontrakty dla repozytoriów, wspieraj¹c separacjê odpowiedzialnoœci, testowanie jednostkowe oraz zasadê Dependency Inversion. Obejmuje nastêpuj¹ce interfejsy:
* IRepository<t></t>: Generyczny interfejs dla operacji CRUD, definiuj¹cy metody takie jak GetAllAsync, GetByIdAsync, AddAsync, UpdateAsync, DeleteAsync, wspieraj¹ce zapytania z IQueryable/IAsyncEnumerable oraz paginacjê.
* Specjalistyczne interfejsy: IAdresyRepository, IAlergenyRepository, IKategorieRepository, IPozycjeMenuRepository, IPozycjeZamowieniaRepository, IUzytkownikRepository, IZamowieniaRepository, ka¿dy rozszerzaj¹cy IRepository<t> o specyficzne metody, np. GetByCategoryIdAsync w IPozycjeMenuRepository.</t>
* IUnitOfWork: Definiuje metodê SaveChangesAsync dla zapewnienia spójnoœci transakcji oraz dostêp do repozytoriów.
Interfejsy s¹ implementowane w warstwie DAL, wykorzystywane przez serwisy BL oraz rejestrowane w DI, co wspiera modularnoœæ i testowalnoœæ kodu.
Warstwa DAL
Warstwa dostêpu do danych (DAL) w przestrzeni TokyoGarden.DAL odpowiada za bezpoœredni dostêp do bazy danych SQL Server, wykorzystuj¹c Entity Framework Core do realizacji operacji CRUD oraz zapytañ z³o¿onych. Warstwa ta zapewnia izolacjê logiki biznesowej od szczegó³ów technicznych bazy danych, wspieraj¹c modularnoœæ i czyst¹ architekturê. Obejmuje nastêpuj¹ce komponenty:
* DbTokyoGarden: Kontekst Entity Framework Core, który zarz¹dza po³¹czeniem z baz¹ danych i definiuje DbSety dla ka¿dej encji, takiej jak U¿ytkownicy czy Zamówienia.
* Repository<t></t>: Generyczne repozytorium dostarczaj¹ce podstawowe operacje CRUD, takie jak GetAllAsync, GetByIdAsync, AddAsync, UpdateAsync oraz DeleteAsync, z AsNoTracking w zapytaniach odczytowych dla optymalizacji wydajnoœci.
* Specjalistyczne repozytoria: UzytkownikRepository, AdresyRepository, AlergenyRepository, KategorieRepository, PozycjeMenuRepository, PozycjeZamowieniaRepository, ZamowieniaRepository, ka¿de rozszerzaj¹ce generyczne repozytorium o specyficzne zapytania, np. GetByUserIdAsync w ZamowieniaRepository.
* UnitOfWork: Klasa zapewniaj¹ca spójnoœæ operacji poprzez metodê SaveChangesAsync, umo¿liwiaj¹c grupowanie operacji w ramach jednej transakcji.
Repozytoria s¹ rejestrowane w kontenerze DI w pliku Program.cs, np. AddScoped<IRepository<t>, Repository<t>>, co umo¿liwia wstrzykiwanie zale¿noœci do serwisów biznesowych. Warstwa DAL zapewnia efektywny dostêp do danych, zachowuj¹c zgodnoœæ z zasadami SOLID.</t></t>
Warstwa IBL
Warstwa interfejsów logiki biznesowej (IBL) w przestrzeni TokyoGarden.IBL definiuje kontrakty dla serwisów logiki biznesowej, wspieraj¹c testowanie jednostkowe, modularnoœæ oraz zgodnoœæ z zasad¹ Dependency Inversion z zestawu zasad SOLID. Interfejsy te s¹ rejestrowane w kontenerze Dependency Injection (DI) w pliku Program.cs, co u³atwia wstrzykiwanie zale¿noœci i wymianê implementacji. Warstwa obejmuje siedem interfejsów, z których ka¿dy odpowiada jednej klasie serwisowej:
1. IAdresyService: Definiuje operacje na adresach, takie jak pobieranie listy adresów, wyszukiwanie po identyfikatorze czy filtrowanie wed³ug miasta, wspieraj¹c logistykê dostaw.
2. IAlergenyService: Okreœla funkcje dla alergenów, umo¿liwiaj¹c ich dodawanie, edytowanie oraz usuwanie w celu informowania o zagro¿eniach zdrowotnych.
3. IKategorieService: Zarz¹dza kategoriami menu, wspieraj¹c tworzenie, edytowanie oraz usuwanie kategorii w celu organizacji oferty kulinarnej.
4. IPozycjeMenuService: Obs³uguje pozycje menu, umo¿liwiaj¹c zarz¹dzanie daniami dostêpnymi w ofercie restauracyjnej.
5. IPozycjeZamowieniaService: Dotyczy pozycji w zamówieniach, wspieraj¹c procesy zwi¹zane z koszykiem zakupowym i finalizacj¹ zamówieñ.
6. IUzytkownikService: Zarz¹dza u¿ytkownikami, oferuj¹c funkcje rejestracji, logowania, edycji profili oraz autoryzacji u¿ytkowników.
7. IZamowieniaService: Obs³uguje zamówienia, umo¿liwiaj¹c ich tworzenie, edytowanie, aktualizacjê statusu oraz filtrowanie wed³ug ró¿nych kryteriów.
Ka¿dy interfejs definiuje asynchroniczne metody, takie jak GetAllAsync, GetByIdAsync, AddAsync, UpdateAsync, DeleteAsync, a niektóre oferuj¹ dodatkowe funkcje, np. AuthenticateAsync w IUzytkownikService dla logowania u¿ytkowników. Interfejsy wspieraj¹ kontrolery API, rejestracjê w DI oraz testy jednostkowe, zapewniaj¹c modularnoœæ i ³atwoœæ utrzymania kodu.
Warstwa Biznesowa
Warstwa biznesowa w aplikacji TokyoGarden, zlokalizowana w przestrzeni nazw TokyoGarden.BL, odpowiada za realizacjê logiki aplikacyjnej, obejmuj¹c¹ przetwarzanie danych, walidacjê, obs³ugê regu³ biznesowych oraz komunikacjê z warstw¹ dostêpu do danych (DAL). Ka¿dy serwis implementuje interfejs z przestrzeni TokyoGarden.IBL, co gwarantuje modularnoœæ, ³atwoœæ testowania oraz zgodnoœæ z zasadami SOLID, w szczególnoœci z zasad¹ Dependency Inversion. Warstwa ta obejmuje siedem klas serwisowych, z których ka¿da odpowiada za operacje na okreœlonym typie danych:
1. AdresyService: Zarz¹dza danymi adresowymi, umo¿liwiaj¹c pobieranie, dodawanie, aktualizacjê oraz usuwanie adresów, a tak¿e filtrowanie wed³ug miasta, co wspiera logistykê dostaw.
2. AlergenyService: Obs³uguje informacje o alergenach, takie jak ich dodawanie, edycja czy usuwanie, co pozwala na informowanie klientów o potencjalnych zagro¿eniach zdrowotnych.
3. KategorieService: Odpowiada za zarz¹dzanie kategoriami menu, umo¿liwiaj¹c tworzenie, edytowanie oraz usuwanie kategorii, co u³atwia organizacjê oferty kulinarnej.
4. PozycjeMenuService: Realizuje operacje na pozycjach menu, takie jak dodawanie nowych dañ, edycja istniej¹cych oraz ich usuwanie, co wspiera zarz¹dzanie ofert¹ restauracji.
5. PozycjeZamowieniaService: Obs³uguje pozycje w zamówieniach, umo¿liwiaj¹c dodawanie, edytowanie oraz usuwanie produktów w koszyku, co jest kluczowe dla procesu zamawiania.
6. U¿ytkownikService: Zarz¹dza danymi u¿ytkowników, w tym rejestracj¹, edycj¹ profili, usuwaniem kont oraz autoryzacj¹, co zapewnia bezpieczeñstwo i personalizacjê us³ug.
7. ZamowieniaService: Realizuje operacje zwi¹zane z zamówieniami, takie jak tworzenie, edycja, aktualizacja statusu oraz filtrowanie, co wspiera procesy biznesowe restauracji.
Ka¿dy serwis komunikuje siê z odpowiadaj¹cym mu repozytorium z warstwy DAL (TokyoGarden.IDAL), korzystaj¹c z interfejsów takich jak IZamowieniaRepository, co zapewnia separacjê odpowiedzialnoœci. Przyk³adowo, AdresyService deleguje operacje do IAdresyRepository i obs³uguje funkcje takie jak GetAllAsync, GetByIdAsync, AddAsync, UpdateAsync, DeleteAsync oraz GetByCityAsync, co pozwala na elastyczne zarz¹dzanie danymi adresowymi. Serwisy BL egzekwuj¹ regu³y biznesowe, takie jak poprawnoœæ cen i iloœci, obecnoœæ kategorii i alergenów, oraz przeliczanie wartoœci zamówienia, mapuj¹c wyj¹tki domenowe na odpowiedzi HTTP (400, 404, 409).
API – Web
Kontrolery w projekcie TokyoGarden, zlokalizowane w warstwie API, obs³uguj¹ komunikacjê RESTful miêdzy frontendem a backendem, realizuj¹c operacje CRUD i zapewniaj¹c spójnoœæ, skalowalnoœæ oraz ³atwoœæ integracji z innymi warstwami aplikacji. Kluczowe cechy kontrolerów to:
* Atrybut [ApiController]: Automatyczna walidacja modelu, zapobiegaj¹ca przetwarzaniu nieprawid³owych danych wejœciowych.
* Routing [Route("api/[controller]")]: Spójna struktura adresów URL dla endpointów API, z wersjonowaniem œcie¿k¹ (np. /api/v1/pozycje-menu).
* Wstrzykiwanie serwisów: Separacja logiki biznesowej od warstwy prezentacyjnej poprzez zale¿noœæ od serwisów BL.
* Zwracanie DTO: Konwersja danych na obiekty DTO za pomoc¹ ToDto(), co zapewnia bezpieczne przesy³anie danych.
* Asynchronicznoœæ: Wykorzystanie async/await dla zwiêkszenia wydajnoœci przetwarzania ¿¹dañ.
Lista kontrolerów:
1. AdresyController: Zarz¹dza adresami, umo¿liwiaj¹c pobieranie listy, wyszukiwanie po ID, dodawanie, aktualizacjê, usuwanie oraz filtrowanie wed³ug miasta, co wspiera logistykê dostaw.
2. AlergenyController: Obs³uguje dane alergenów, umo¿liwiaj¹c ich dodawanie, edytowanie oraz usuwanie, co zapewnia informowanie klientów o zagro¿eniach zdrowotnych.
3. KategorieController: Zarz¹dza kategoriami menu, wspieraj¹c tworzenie, edytowanie, usuwanie oraz wyszukiwanie po nazwie, co u³atwia organizacjê oferty.
4. PozycjeMenuController: Realizuje operacje na pozycjach menu, umo¿liwiaj¹c zarz¹dzanie daniami w ofercie restauracyjnej.
5. PozycjeZamowieniaController: Obs³uguje pozycje w zamówieniach, wspieraj¹c procesy koszyka zakupowego i finalizacji zamówieñ.
6. UzytkownicyController: Zarz¹dza u¿ytkownikami, obs³uguj¹c rejestracjê, edycjê profili, usuwanie kont (z powi¹zanymi zamówieniami) oraz autoryzacjê, co zapewnia bezpieczeñstwo systemu.
7. ZamowieniaController: Obs³uguje zamówienia, umo¿liwiaj¹c tworzenie, edytowanie, aktualizacjê statusu, usuwanie oraz filtrowanie wed³ug u¿ytkownika, statusu lub daty, co wspiera rozliczenia i logistykê.
Przyk³adowe endpointy:
* GET /api/v1/uzytkownicy: Pobiera listê wszystkich u¿ytkowników w systemie, zwracaj¹c ich dane w formacie DTO z paginacj¹ i sortowaniem.
* POST /api/v1/alergeny: Dodaje nowy alergen do bazy danych, zwracaj¹c kod 201 (Created) z nag³ówkiem Location wskazuj¹cym na nowy zasób.
* PUT /api/v1/zamowienia/5: Aktualizuje zamówienie o identyfikatorze 5, uwzglêdniaj¹c status i pozycje zamówienia, z walidacj¹ danych wejœciowych.
* DELETE /api/v1/kategorie/4: Usuwa kategoriê o identyfikatorze 4, zwracaj¹c kod 204 (No Content) po sukcesie, z obs³ug¹ b³êdów integralnoœci.
Kontrolery zapewniaj¹ bezpieczeñstwo poprzez hashowanie hase³ (BCrypt.Net), walidacjê danych oraz obs³ugê b³êdów (kody HTTP: 200, 201, 204, 400, 404, 409). B³êdy s¹ zwracane jako ProblemDetails z tytu³em, statusem i szczegó³ami, np. 409 dla konfliktów integralnoœci lub 404 dla nieistniej¹cych zasobów. Endpointy listowe wspieraj¹ parametry zapytañ (page, pageSize, sortBy, sortDir, filters[]), które BL/DAL mapuje na zapytania LINQ/EF Core.
DtoMapper.cs
Klasa statyczna DtoMapper w przestrzeni TokyoGarden.Api odpowiada za konwersjê encji bazodanowych na obiekty DTO, zapewniaj¹c bezpieczne i efektywne przesy³anie danych miêdzy backendem a frontendem, minimalizuj¹c ryzyko ujawnienia wra¿liwych informacji. Wykorzystuje LINQ do przekszta³cania kolekcji i metody rozszerzeñ (this), co poprawia czytelnoœæ kodu. Obejmuje siedem metod mapuj¹cych:
1. ToDto(Uzytkownicy): Konwertuje encjê Uzytkownicy na DTO, zawieraj¹ce identyfikator, nazwê u¿ytkownika, telefon oraz typ u¿ytkownika, pomijaj¹c wra¿liwe dane, takie jak has³o.
2. ToDto(Adresy): Przekszta³ca encjê Adresy na DTO z danymi lokalizacyjnymi, takimi jak miasto, ulica, numer domu oraz numer mieszkania, co wspiera logistykê dostaw.
3. ToDto(Kategorie): Mapuje encjê Kategorie na DTO z identyfikatorem i nazw¹ kategorii, co u³atwia prezentacjê kategorii menu w interfejsie u¿ytkownika.
4. ToDto(Alergeny): Przekszta³ca encjê Alergeny na DTO z nazw¹ alergenu, co pozwala na zwiêz³e przekazywanie informacji o zagro¿eniach zdrowotnych.
5. ToDto(Pozycje_Menu): Konwertuje encjê Pozycje_Menu na DTO z nazw¹, opisem, cen¹ oraz powi¹zan¹ kategori¹, stosuj¹c zagnie¿d¿one mapowanie dla pe³nych danych.
6. ToDto(Pozycje_Zamowienia): Przekszta³ca encjê Pozycje_Zamowienia na DTO z iloœci¹, cen¹ oraz powi¹zan¹ pozycj¹ menu, wspieraj¹c szczegó³owe okreœlenie koszyka.
7. ToDto(Zamowienia): Konwertuje encjê Zamowienia na DTO z danymi takimi jak data, status, cena, u¿ytkownik (jako DTO) oraz lista pozycji zamówienia, mapowana za pomoc¹ LINQ.
Metody zawieraj¹ zabezpieczenia przed null (np. == null ? null!), zapewniaj¹c bezpieczeñstwo i eliminuj¹c ostrze¿enia kompilatora.
DTO
Pakiet TokyoGarden.Api.DTOs zawiera klasy DTO, które reprezentuj¹ dane w uproszczonej formie, pomijaj¹c logikê biznesow¹ i zale¿noœci bazodanowe, co zapewnia bezpieczeñstwo, czytelnoœæ oraz wydajnoœæ przesy³ania danych miêdzy backendem a frontendem. Obiekty DTO s¹ wykorzystywane w kontrolerach API oraz serwisach, wspieraj¹c separacjê warstw i odpornoœæ na b³êdy.
Frontend – Angular
Frontend systemu TokyoGarden, zbudowany w Angular, opiera siê na modularnej strukturze z podzia³em na modu³y, takie jak admin, shared i core, co u³atwia zarz¹dzanie kodem i jego ponowne wykorzystanie. Wykorzystuje serwisy HTTP do komunikacji z API, interceptory do obs³ugi b³êdów oraz formularze reaktywne z walidacjami min/max i wymaganymi polami. Kluczowe elementy to:
* Struktura: Modu³ Admin Panel zawiera widoki list i formularzy edycji dla kategorii, alergenów i pozycji menu; modu³ shared dostarcza wspólne komponenty i modele.
* UX i walidacje: Pola wymagane s¹ oznaczone, formaty liczbowe stosowane dla cen, komunikaty o b³êdach wyœwietlane przy utracie fokusu lub próbie wys³ania formularza. Widoki list wspieraj¹ paginacjê i filtrowanie po kategoriach lub alergenach, a edycja realizowana jest w formularzach dialogowych.
* Mapowanie DTO: Formularze generuj¹ DTO dla ¿¹dañ API, a odpowiedzi API s¹ przekszta³cane na modele widoków. Aktualizacje realizowane s¹ przez PUT (idempotentne) lub PATCH (czêœciowe zmiany) w zale¿noœci od potrzeb.
Bezpieczeñstwo i zgodnoœæ
System TokyoGarden zapewnia bezpieczeñstwo poprzez:
* Autoryzacja i role: Wariant MVP obejmuje role Admin/User, zabezpieczone atrybutami autoryzacji w kontrolerach, z planowan¹ rozbudow¹ o JWT Bearer z krótkim TTL i mechanizmem odœwie¿ania tokenów.
* CORS i ochrona danych: Polityka CORS ograniczona do domen frontendu (np. http://localhost:4200), sekrety przechowywane w zmiennych œrodowiskowych, walidacja rozmiarów uploadów (np. imageData), sanitizacja danych tekstowych.
4. Testy (podejœcie i zakres)
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci
Zasady ogólne
Testy w systemie TokyoGarden s¹ realizowane przy u¿yciu frameworka xUnit, stosuj¹c nomenklaturê AAA (Arrange–Act–Assert) oraz izolacjê przypadków testowych, co zapewnia czytelnoœæ i niezawodnoœæ. Skupiaj¹ siê na weryfikacji regu³ biznesowych, spójnoœci danych oraz poprawnoœci operacji w warstwach BL, DAL i API.
Doubles w³asne i Moq
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci.W bibliotece Moq stosuje siê Setup/Returns dla konfiguracji zachowañ oraz Verify dla weryfikacji interakcji, co pozwala na precyzyjne testowanie zale¿noœci.
Testy wykorzystuj¹ ró¿ne typy obiektów zastêpczych:
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci.
Dummy: Parametry obowi¹zkowe, które nie s¹ u¿ywane w teœcie, np. puste obiekty dla niewp³ywaj¹cych na wynik pól.
Stub: Obiekty zwracaj¹ce deterministyczne dane, np. repozytorium zwracaj¹ce sta³¹ listê pozycji menu.
Fake: Proste implementacje, np. kolekcje in-memory dla szybkich testów warstwy BL.
Mock: Obiekty weryfikuj¹ce interakcje, np. sprawdzenie, czy BL wywo³a³o metodê Save lub Update na repozytorium.
Spy: Obiekty rejestruj¹ce liczbê wywo³añ lub szczegó³y metod dla szczegó³owej weryfikacji.
W bibliotece Moq stosuje siê Setup/Returns dla konfiguracji zachowañ oraz Verify dla weryfikacji interakcji, co pozwala na precyzyjne testowanie zale¿noœci.
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci
Testy DAL z InMemory
Testy kontrolerów obejmuj¹:
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci.
Testy jednostkowe: Weryfikacja statusów HTTP i kontraktów API z zamockowan¹ warstw¹ BL, np. sprawdzenie, czy GET /api/v1/uzytkownicy zwraca kod 200 i listê DTO.
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci.
Testy integracyjne: Uruchamianie minimalnego hosta ASP.NET Core, weryfikuj¹cego routing, serializacjê JSON oraz walidacjê ModelState, co zapewnia poprawnoœæ dzia³ania endpointów w rzeczywistych warunkach.
Rozbudowano testy o dodatkowe scenariusze: przypadki b³êdnych danych wejœciowych, testy walidacji, testy wydajnoœciowe sprawdzaj¹ce zachowanie przy du¿ej liczbie rekordów. Dodatkowo wprowadzono testy regresyjne aby zapewniæ, ¿e nowe zmiany nie psuj¹ istniej¹cych funkcjonalnoœci.
5. Interfejs Web API (kontrakt i zasady)
Doprecyzowano kontrakty REST – opisano wszystkie pola w DTO, podano przyk³adowe requesty i response’y dla metod GET, POST i PUT. Uwzglêdniono równie¿ obs³ugê b³êdów z kodami statusu i formatem ProblemDetails. Dodano sugestie wersjonowania API w przysz³oœci (np. /api/v2) w razie rozbudowy systemu
Konwencje REST
Rzeczowniki w liczbie mnogiej, wersjonowanie œcie¿k¹ (np. /api/v1/pozycje-menu), kody statusu zgodne z rezultatem operacji, Location header po POST 201.
Przyk³adowe zasoby i operacje
* /api/v1/kategorie: GET (lista z paginacj¹ i sortowaniem), POST (tworzenie kategorii), GET/{id} (szczegó³y), PUT/{id} (aktualizacja), DELETE/{id} (usuniêcie).
* /api/v1/alergeny: Jak powy¿ej, z operacjami CRUD dla alergenów.
* /api/v1/pozycje-menu: GET z filtrowaniem po kategoriach i alergenach, operacje CRUD dla pozycji menu.
* /api/v1/zamowienia: GET (lista z filtrowaniem po statusie lub u¿ytkowniku), POST (tworzenie zamówienia z pozycjami), PUT/PATCH (aktualizacja statusu lub szczegó³ów).
* /api/v1/uzytkownicy: CRUD dla u¿ytkowników, z dodatkowym endpointem /api/v1/uzytkownicy/{id}/adresy dla zarz¹dzania adresami u¿ytkownika.
Walidacja i b³êdy
Walidacja DTO jest realizowana na poziomie kontrolerów, z b³êdami zwracanymi jako ProblemDetails (tytu³, status, szczegó³y). Przyk³ady:
* Kod 400 dla nieprawid³owych danych (np. cena < 0).
* Kod 404 dla nieistniej¹cych zasobów (np. u¿ytkownik o danym ID).
* Kod 409 dla konfliktów integralnoœci (np. próba usuniêcia kategorii z powi¹zanymi pozycjami menu).
Paginacja/sortowanie/filtrowanie
Endpointy listowe wspieraj¹ parametry zapytañ, takie jak page, pageSize, sortBy, sortDir, filters[], które s¹ mapowane przez BL i DAL na zapytania LINQ/EF Core, zapewniaj¹c elastycznoœæ i wydajnoœæ w przetwarzaniu du¿ych zbiorów danych.

6. Frontend (Angular)
UI zosta³o wzbogacone o szczegó³owe formularze z walidacj¹ na ¿ywo, komunikaty o b³êdach w czasie rzeczywistym oraz responsywny design dostosowany do urz¹dzeñ mobilnych. Dodano przyk³ady interakcji u¿ytkownika i zrzuty ekranu (opisowo) pokazuj¹ce przep³yw procesu od dodania pozycji menu po realizacjê zamówienia.
Struktura i wzorce
Struktura modu³owa (np. admin, shared). Serwisy API kapsu³kuj¹ wywo³ania HTTP; komponenty korzystaj¹ z formularzy reaktywnych (walidacje min/max, wymagane pola).
Doprecyzowano kontrakty REST – opisano wszystkie pola w DTO, podano przyk³adowe requesty i response’y dla metod GET, POST i PUT. Uwzglêdniono równie¿ obs³ugê b³êdów z kodami statusu i formatem ProblemDetails. Dodano sugestie wersjonowania API w przysz³oœci (np. /api/v2) w razie rozbudowy systemu.
UX i walidacje
Pola wymagane oznaczone, formaty liczbowe dla cen, komunikaty o b³êdach przy focus out i submit. Widoki list obs³uguj¹ paginacjê, filtrowanie po kategorii/alergenach; edycja w formularzach dialogowych.
Mapowanie DTO
Formularze ? DTO request ? API; odpowiedzi API ? modele widoków. Idempotencja aktualizacji przez PUT, czêœciowe zmiany przez PATCH tam, gdzie wskazane.
Doprecyzowano kontrakty REST – opisano wszystkie pola w DTO, podano przyk³adowe requesty i response’y dla metod GET, POST i PUT. Uwzglêdniono równie¿ obs³ugê b³êdów z kodami statusu i formatem ProblemDetails. Dodano sugestie wersjonowania API w przysz³oœci (np. /api/v2) w razie rozbudowy systemu.
7. Bezpieczeñstwo i zgodnoœæ
Autoryzacja i role
Wariant MVP: role Admin/User; kontrolery zabezpieczone atrybutami autoryzacji. Docelowo JWT Bearer z krótkim TTL i odœwie¿aniem.
CORS i ochrona danych
CORS ograniczony do domen frontendu. Sekrety w zmiennych œrodowiskowych. Walidacja rozmiarów uploadów (np. image_data). Sanitizacja danych tekstowych.
2


